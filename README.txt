pk
=========

pk stands for Password Keeper

Usage:
  pk [command]

Available Commands:
  add         add new details to db
  delete      delete details of an account
  get         get account details
  help        Help about any command
  init        initialize pk
  list        list the details of all accounts
  login       generate auth token
  update      update account details

Flags:
      --config string       config file (default is $HOME/.pk.yaml)
  -e, --email string        email of the account
  -h, --help                help for pk
  -n, --name string         name of the account (e.g github)
  -p, --passphrase string   the account password
  -t, --token string        auth token
  -u, --username string     username of the account (e.g alicebob)
  -v, --verbose             verbose command output

Use "pk [command] --help" for more information about a command.


Implementation Details
========================

pk uses bcrypt to hash the master password, which is never known to application
or stored as plain text.
The user should at all times remember the master password

For user to perform any command after (apart from pk init and pk login) he/she
needs a JWT token that can be generated by running (pk login) command. A user have
to provide the authorization token hence forth

The token is very short lived bout 10 minutes (I think of making it 5 minutes)


pk uses RSA to encode and sign the plaintext (password) before storing them,
it also create message sum using RSA. Upon retrieving the signature is
recreated using after using a decoded plaintext from stored ciphertext, then
comparison of the signature and bcrypt hash are made. If they all pass the details
are returned if not pk assumes that the db is compromised and your data are not
what you stored (they have been changed)

Plan
=====
To use sqlite or any other embedded database
To add other ciphers especially ECC
To install certificates to System Certs Pool

Why pk?
========
I just made the tool as a playground to be able to experiment with databases,
authentication and authorization, cryptography, linux env, command line tools,
runtime complication etc etc etc

If you are getting started with golang this may be a good place to experiment



Disclaimer
===========
Use at your own risk. The developer has no control or responsibilities for any
results good/bad when this tool is used by anyone for any purpose.